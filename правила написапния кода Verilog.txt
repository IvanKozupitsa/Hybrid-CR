Соглашение по разработке кода Verilog и проч.:
1) Стандартный отступ - три пробела, причем табуляция заменяется пробелами.
2) Название модуля и его входных\выходных переменный должно быть следующего вида.

```Verilog
module myTestNameModule( iCLK, iRESET, iCE, 
                         iREAL_DATA, iIMAG_DATA, 
                         oREAL_DATA, oIMAG_DATA 
                        );
```
3) Объявление входных и выходных портов. Название входного порта начинается с префикса i, выходного - с префикса o

```Verilog
input wire iCLK;
input wire iRESET;
input wire iCE;
input wire [5:0] iREAL_DATA;
input wire [5:0] iIMAG_DATA;
...
output reg [31:0] oREAL_DATA;
output reg [31:0] oIMAG_DATA ;
```
4) Объявление регистров и проводов.

```Verilog
wire [7:0] flagOutSignal;
reg [7:0] generalCounter;
reg [7:0] generalArray [0:5];
```
5) Следующие конструкции выделяются отступами:
5.1) При описание блока always используется следующий синтаксис.

 ```Verilog
always @ ( <sensitivity_list> ) <statements>
```
5.2) Описание блока initial

 ```Verilog
initial begin
   CLK = 0;
   RESET = 1;
end
```
5.3) Содержимое конструкции **begin - end**

 ```Verilog
begin
   RESET <= 0;
   CLK <= 1;
end
```
5.4) Операторы выбора
5.4.1) Оператор if-else
Однострочное тело

 ```Verilog
if ( a = 0 )
   b = c;
else
   d = 1;
```
Многострочное тело

 ```Verilog
if ( a = 0 ) begin
   b = c;
   d = e;
end
else begin
   b = 1;
   d = 1;
end
```

5.4.2) Оператор case

 ```Verilog
case ( myCase )
   1'b0: begin
      a <= 1;
      b <= 0;
   end
   1'b1: begin
      a <= 0;
      b <= 1;
   end
endcase 
```

5.5) generate

 ```Verilog
genvar i;
generate
   for ( i = 0; i < 3; i = i + 1 ) begin 
      always @ ( posedge CLK ) begin
         tempA[i]  <= 1'b0;
         tempB[i]  <= 1'b1;
      end
   end
endgenerate 
 ```

5.6) Параметры, константы и переменные

```Verilog
parameter COEF_A = 2;
parameter COEF_B = 4;

localparam COEF_C = 6;
localparam COEF_D = 8;
 
wire flag;
logic [4:0] count;
```

6) Подключение модуля

 ```Verilog
moduleName #( param0,
               param1,
               param2 ) instanceName( .CLOCK( CLK ),
                                      .RESET( RST ),
                                      .DATA( D ), 
                                      .OUT( RESULT ) );
 ```

7)  Имена модулей, регистров и проводов в Венгерской нотации - написание модулей, регистров и проводов начинается с маленькой буквы. Если имя состоит из нескольких слов - каждое из составных слов, кроме первого, начинается с заглавной буквы:

```
nameModule
flagFinishData
countValueCirc
```

8) Определение локальных переменных

 ```Verilog
localparam INPUT_WIDTH = 18;     // Разрядность входного сигнала
localparam INPUT_MAX_INDEX = 17; // Максимальный индекс входного сигнала
 ```
К локальным переменным всегда пишутся комментарии.

9) Объявление экземпляра модуля:

 ```Verilog
moduleName instanceName( .CLOCK( CLK ),
                          .RESET( RST ),
                          .DATA( D ), 
                          .OUT( RESULT ) );
 ```
10) Тело модуля имеет стандартный отступ (три пробела), а также объявление модуля отделяется от тела пустыми строками:
```Verilog
module myTestNameModule( CLK, INPUT, OUTPUT );

   localparam INPUT_SIZE = 5;

   input wire CLK;
   input wire INPUT;
   output wire OUTPUT;
   ...

endmodule: myTestNameModule
```
11) Блоки циклов и операторов условного перехода отделяется друг от друга, а также от остальной части кода, пробелами. Если они начинаются сразу после объявления блока, верхний отделяющий пробел не ставится. Пример:
```Verilog
for ( int i = 0; i < 10; ++i ) begin
   if ( a < b ) begin
      ...
   end

   for ( int j = 0; j < 10; ++j ) begin
      ...
   end
   
   if ( ... ) begin
      ...
   end
   else ( ... ) begin
      ...
   end
end
```
12) В testbench имя регистра, используемого для  имитации входа или выхода тестируемого модуля, состоит из названия соответствующего порта данного модуля и постфикса DUT. Пример:
 ```Verilog
bit CLOCK_DUT;                    // Тактовый сигнал тестируемого модуля
logic [INPUT_WIDTH:0] INPUT_DUT;  // Входной сигнал тестируемого модуля